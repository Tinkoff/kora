/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) ({{{generatorVersion}}}).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package {{apiPackage}}

import java.util.function.Function;

import ru.tinkoff.kora.common.Context
import ru.tinkoff.kora.common.Module
import ru.tinkoff.kora.common.Tag
import ru.tinkoff.kora.common.DefaultComponent
import ru.tinkoff.kora.common.Principal
import ru.tinkoff.kora.config.common.extractor.ConfigValueExtractor
import ru.tinkoff.kora.http.server.common.HttpServerInterceptor
import ru.tinkoff.kora.http.server.common.HttpServerRequest
import ru.tinkoff.kora.http.server.common.HttpServerResponse
import ru.tinkoff.kora.http.server.common.HttpServerResponseException
import com.typesafe.config.Config
import reactor.core.publisher.Mono


import ru.tinkoff.kora.http.common.auth.*
import ru.tinkoff.kora.http.server.common.auth.*



@Module
@ru.tinkoff.kora.common.annotation.Generated("openapi generator kora client")
public interface ApiSecurity {
{{#vendorExtensions.tags}}
    class {{.}} {}
{{/vendorExtensions.tags}}

{{#vendorExtensions.authMethods}}
    class {{name}}HttpServerInterceptor(
        {{#methods}}  @Tag(ApiSecurity.{{#lambda.classname}}{{name}}{{/lambda.classname}}::class) val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}: HttpServerPrincipalExtractor<{{#isOAuth}}PrincipalWithScopes{{/isOAuth}}{{^isOAuth}}Principal{{/isOAuth}}>{{^vendorExtensions.isLast}},
        {{/vendorExtensions.isLast}}{{/methods}}
    ) : HttpServerInterceptor {

        override fun intercept(request: HttpServerRequest, chain: Function<HttpServerRequest, Mono<HttpServerResponse>>): Mono<HttpServerResponse> {
            return Mono.deferContextual{ ctx ->
                val context = Context.Reactor.current(ctx){{#methods}}{{#isApiKey}}{{#isKeyInHeader}}
                val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("{{keyParamName}}"){{/isKeyInHeader}}{{#isKeyInQuery}}
                val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query = request.queryParams().get("{{keyParamName}}")
                val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = if ({{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query == null || {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query.isEmpty())
                  null else {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_query.iterator().next();
                {{/isKeyInQuery}}{{#isKeyInCookie}}
                  throw IllegalStateException("TODO");// TODO
                {{/isKeyInCookie}}
                {{/isApiKey}}{{#isBasicBasic}}
                val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization")
                {{/isBasicBasic}}{{#isBasicBearer}}
                val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization")
                {{/isBasicBearer}}{{#isOAuth}}
                val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token = request.headers().getFirst("Authorization")
                {{/isOAuth}}


                val {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}} = this.{{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}.extract(request, {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}_token){{^isOAuth}}{{/isOAuth}}{{#isOAuth}}{{#vendorExtensions.hasScopes}}
                  .handle<Principal> { principal, sink -> {{#scopes}}
                     if (!principal.scopes().contains("{{scope}}")) throw HttpServerResponseException.of(403, ""){{/scopes}}
                     sink.next(principal)
                  }{{/vendorExtensions.hasScopes}}{{/isOAuth}}{{/methods}}{{#methods}}{{#vendorExtensions.isFirst}}

                {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}{{/vendorExtensions.isFirst}}{{/methods}}{{#methods}}{{^vendorExtensions.isFirst}}
                  .switchIfEmpty(Mono.defer { {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}} }){{/vendorExtensions.isFirst}}{{/methods}}
                  .switchIfEmpty(Mono.error { HttpServerResponseException.of(403, "") })
                  .doOnNext { principal -> Principal.set(context, principal) }
                  .then(Mono.defer { chain.apply(request) });
            }
        }
    }

    @Tag({{name}}::class)
    @DefaultComponent
    fun {{#lambda.camelcase}}{{name}}HttpServerInterceptor{{/lambda.camelcase}}({{#methods}}
      @Tag(ApiSecurity.{{#lambda.classname}}{{name}}{{/lambda.classname}}::class) {{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}: HttpServerPrincipalExtractor<{{#isOAuth}}PrincipalWithScopes{{/isOAuth}}{{^isOAuth}}Principal{{/isOAuth}}>{{^vendorExtensions.isLast}},
      {{/vendorExtensions.isLast}}{{/methods}}): {{name}}HttpServerInterceptor {
        return {{name}}HttpServerInterceptor({{#methods}}{{#lambda.camelcase}}{{name}}{{/lambda.camelcase}}{{^vendorExtensions.isLast}}, {{/vendorExtensions.isLast}}{{/methods}})
    }

{{/vendorExtensions.authMethods}}

}
